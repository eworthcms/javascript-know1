# 实质问题

**当函数可以记住并访问所在的词法作用域时**，**就产生了闭包，即使函数是在当前词法作用域之外执行。**

```javascript
//下边的例子是一个 RHS 引用查询
//bar()对a的引用方法是词法作用域查找规则
function foo(){
    var a = 2;
    function bar(){
        console.log(a);  //2
    }
    bar();
}
foo();
```

```javascript
//闭包
function foo(){
    var a = 2;
    function bar(){
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz();  //2 这是闭包的效果
```

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()

bar() 显然可以被正常执行。它在自己定义的词法作用域以外的地方执行。

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然的会考虑对其就行回收。

而闭包的神奇之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。

**源于 bar() 所声明的位置，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后的任何时间进行引用。**

bar() 依然持有对该作用域的引用，而这个引用就叫做闭包。

所以 baz 被实际调用（调用内部函数bar），不出意外它可以访问定义时的词法作用域，因此可以访问变量a。

这个函数在定义时词法作用域以外的地方被调用。**闭包使得函数可以继续访问定义时的词法作用域。**



```javascript
//https://tylermcginnis.com/  可视化查看闭包 并用gif软件来录屏
function foo(){
    var a = 2;
    function bar(){
        console.log(a);  //2
    }
    bar();
}
foo();
var a = 10;
```



无论使用何种方式 **对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包**。

```javascript
function foo(){
    var a = 2;
    function baz(){
        console.log(a);  //2
    }
    bar(baz);
}

function bar(fn){
    fn();  //这是闭包
}

foo();
```

把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫做fn），它覆盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问变量a

```javascript
//传递函数也可以是间接的
var fn;
function foo(){
    var a = 2;
    function baz(){
        console.log(a);
    }
    fn = baz;  //将baz分配给全局变量
}

function bar(){
    fn();  //闭包
}

foo();
bar();  //2
```

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。



**只要将函数作为值传递，就会形成一个闭包。**









































