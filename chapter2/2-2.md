# 欺骗词法

定义上下文和运行上下文 => 感觉作用域就是上下文的意思。

词法作用域由写代码时函数所声明的位置定义，如何在运行时修改词法作用域？ => 运行上下文

以下两种机制可以实现，但是欺骗词法作用域会导致性能下降。

## eval

JavaScript 的 `eval(...)` 函数接受一个 **字符串** 为参数，将其中的字符串内容视为好像在书写时就存在于程序中这个位置的代码。

在执行 `eval(...)` 之后的代码时，引擎并不关心前面的代码是以动态形式插入进来对词法作用域环境进行修改的。引擎会如往常一样进行词法作用域查找。



```javascript
function foo(str,a){
    eval(str);  //欺骗 在内部创建了一个变量b,屏蔽了全局作用域的同名变量b
    console.log(a,b);
}
var b = 2;
foo("var b = 3;",1):  //1,3
```



`eval(..)` 可以在运行时对定义时的词法作用域进行修改。严格模式下，`eval(..)` 在运行时锁死在自己的词法作用域中，其中的声明无法修改所在的作用域。

```javascript
function foo(str){
    "use strict";
    eval(str);
    console.log(a);  // ReferenceError:a is not defined
}
foo("var a = 2");
```

`setTimeout(..)` 和 `setInterval()` 的第一个参数可以是字符串，字符串的内容解析为动态生成的函数代码。



## with

`with` 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身

```javascript
var obj = {
    a: 1,
    b: 2,
    c: 3
};

//单调乏味的重复 obj
obj.a = 2;
obj.b = 3;
obj.c = 4;

//简单的快捷方式 方便访问对象属性
with(obj){
    a = 3;
    b = 4;
    c = 5;
}
```



`with` 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性会被处理为定义在这个作用域中的词法标识符。

尽管 `with` 块可以将一个对象处理为词法作用域，但是这个块内部正常的 `var` 声明并不会被限制在这个块的作用域中，而是被添加到 `with` 所处的函数作用域中。



---



`eval()` 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 `with` 声明，实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。



不推荐使用 `eval()` 和 `with`，因为会被严格模式所影响（限制）。`with` 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 `eval()` 也被禁止了。



## 性能

`eval()` 和 `with` 会在运行时修改或创建新的作用域，以此来欺骗定义时的词法作用域。

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行 **静态分析**，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 `eval()` 或 `with`，它先假设这段标识符位置的判断无效，致使所有的优化可能变成无意义的。=> 悲观锁。























