# 理解作用域

> cosplay 模拟场景，生动有趣



```javascript
//进行处理的全过程
var a = 2;
```

## 演员表

* 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程

* 编译器

  负责语法分析及代码生成

* 作用域

  负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限 => 变量的查找范围



## 三方对话

```javascript
var a = 2;
```

引擎在这里有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。



`var a = 2` 的执行过程

分解为词法单元(编译器) => 树结构(AST) => 代码生成(编译器)

### 处理过程

编译器首先会将这段程序分解为词法单元，然后将词法单元解析成一个树结构。当编译器开始进行代码生成时，处理方式如下



#### 错误的解读

为一个变量分配内存，将其命名为a，然后将值2保存进整个变量



#### 正确的解读

1. 编译器遇到`var a`,会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则，要求作用域在当前作用域的集合中声明一个新变量，命名为a

2. 编译器会为引擎生成运行时的代码，这些代码用于处理 `a = 2` 这个赋值操作。
   引擎运行时首先询问作用域，当前的作用域集合中是否存在一个叫 a 的变量，如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了a变量，就会把2赋值给它，否则引擎抛出一个异常！



### 总结

变量的赋值操作会执行两个动作：首先编译器会在 **当前作用域** 中声明一个变量（如果之前没有声明过），然后在运行时引擎会在 **作用域** （作用域链）中查找该变量，如果能够找到就对它赋值。



## 编译器有话说

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。

查找的过程由作用域进行协助，而引擎执行怎样的查找，会影响最终的查找结果。



`var a = 2` 在执行阶段，引擎会为变量a进行 `LHS` 查询，也就是左查询。

当变量出现在赋值操作(`=`)的左边时进行`LHS`查询，出现在右边时进行`RHS`查询。



`RHS`查询与简单的查找某个变量的值没区别，而`LHS`查询是试图找到变量的容器本身，从而可以对其赋值。`RHS`并不是真正意义上的“赋值操作的右侧”，更准确的说是“非左侧”

`RHS` 是在作用域链上查找(retrieve his source value 取得源值)



### 左右值的案例

> LHS 和 RHS 的含义是“赋值操作的左侧和右侧”，并不一定意味着就是 “=” 赋值操作符的左侧或右侧。赋值操作还有其他几种形式，应该理解为 “赋值操作的目标是谁（LHS）” 以及 “谁是赋值操作的源头（RHS）”



#### case A

```javascript
console.log(a)       //a是右值 console.log()也是右值
a = 2;               //a是左值
```

对a的引用是一个RHS引用，因为这里a没赋值操作，而是需要查找并取得a的值，才能将值传递给console.log(...)



#### case B

```javascript
function foo(a){
    console.log(a);  //2
}

foo(2);
```

最后一行的 `foo(...)` 函数的调用需要对 foo 进行 RHS 引用

`function foo(a)` 这里把2当作参数传递给a的时候，对a进行 LHS 查询

`console.log(a)` 这里对 a 进行 RHS 查询

`console.log(...)` 这里对 console 对象进行 RHS 查询

































